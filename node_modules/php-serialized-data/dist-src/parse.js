let objectReferences;
let parseOptions = {};
export function parse(input, options = {}) {
    objectReferences = [null];
    parseOptions = options;
    return _parse(input);
}
function _parse(input) {
    if (typeof input !== 'string') {
        throw new TypeError('Input must be a string');
    }
    input = input.trim();
    const tokenIdentifier = input.substr(0, 1);
    if (tokenIdentifier in PHPTypes.identifierMap) {
        return PHPTypes.identifierMap[tokenIdentifier].build(input);
    }
    else {
        throw new Error(`Failed to match identifier "${tokenIdentifier}".`);
    }
}
export function toJs(object, options = {}, seen = new WeakMap()) {
    if (!object || typeof object !== 'object')
        return object;
    const objectClass = object.constructor;
    if (!Object.values(PHPTypes.identifierMap).includes(objectClass)) {
        return object;
    }
    if (object instanceof PHPTypes.PHPReference) {
        object = object.value;
    }
    if (seen.has(object)) {
        return seen.get(object);
    }
    const jsValue = objectClass.toJs(object, options);
    seen.set(object, jsValue);
    if (object instanceof PHPTypes.PHPArray || object instanceof PHPTypes.PHPObject) {
        const objectValue = jsValue;
        for (let [key, value] of Object.entries(objectValue)) {
            jsValue[key] = toJs(value, options, seen);
        }
    }
    return jsValue;
}
export function parseFixedLengthString(input, openingDelimiter = '"', closingDelimiter = '"') {
    const byteCountRegex = /(\d+):/;
    const byteCountMatches = input.match(byteCountRegex);
    if (byteCountMatches !== null) {
        let offset = byteCountMatches[0].length;
        const byteCount = parseInt(byteCountMatches[1]);
        if (input.substr(offset, openingDelimiter.length) === openingDelimiter) {
            offset += openingDelimiter.length;
        }
        else {
            throw new Error('Failed to parse fixed-length string');
        }
        // We need to read bytes manually so the lengths match up with PHP.
        const encoder = new TextEncoder();
        const decoder = new TextDecoder();
        const allBytes = encoder.encode(input.substr(offset));
        const valueBytes = allBytes.slice(0, byteCount);
        const value = decoder.decode(valueBytes);
        offset += value.length;
        if (input.substr(offset, closingDelimiter.length) === closingDelimiter) {
            offset += closingDelimiter.length;
        }
        else {
            if (parseOptions.fixNulls) {
                // Let's see what we can do about this
                // Maybe the nulls have been converted into a replacement character.
                // This is the easiest to fix.
                if (value.substr(0, 1) === '\ufffd') {
                    input = input.replace(/\ufffd/g, '\u0000');
                    return parseFixedLengthString(input, openingDelimiter, closingDelimiter);
                }
                // Maybe the nulls are missing, and we overshot the end of the string.
                let nullCount;
                const valueStart = byteCountMatches[0].length + openingDelimiter.length;
                // Check for lambdas. String should have ended one byte early, and the value should start with "lambda_".
                nullCount = 1;
                if (decoder.decode(allBytes.slice(byteCount - nullCount, byteCount - nullCount + closingDelimiter.length + 1)) === closingDelimiter + ';'
                    && /^lambda_\d+$/.test(value.substr(0, value.length - nullCount))) {
                    input = input.substr(0, valueStart) + '\u0000' + input.substr(valueStart);
                    let [value] = parseFixedLengthString(input, openingDelimiter, closingDelimiter);
                    return [value, offset - nullCount + closingDelimiter.length]; // Original offset to keep everything matched up
                }
                // Check for protected properties with a leading asterisk. String should have ended two bytes early.
                nullCount = 2;
                if (decoder.decode(allBytes.slice(byteCount - nullCount, byteCount - nullCount + closingDelimiter.length + 1)) === closingDelimiter + ';'
                    && value.substr(0, 1) === '*') {
                    input = input.replace('*', '\u0000*\u0000');
                    let [value] = parseFixedLengthString(input, openingDelimiter, closingDelimiter);
                    return [value, offset - nullCount + closingDelimiter.length]; // Original offset to keep everything matched up
                }
                // Check for private properties. String should have ended two bytes early.
                nullCount = 2;
                if (decoder.decode(allBytes.slice(byteCount - nullCount, byteCount - nullCount + closingDelimiter.length + 1)) === closingDelimiter + ';') {
                    // Can't determine the class name from here.
                    // Just prefix with two nulls and check in the toJS method.
                    input = input.substr(0, valueStart) + '\u0000\u0000' + input.substr(valueStart);
                    let [value] = parseFixedLengthString(input, openingDelimiter, closingDelimiter);
                    return [value, offset - nullCount + closingDelimiter.length]; // Original offset to keep everything matched up
                }
            }
            else {
                throw new Error('Failed to parse fixed-length string');
            }
        }
        return [value, offset];
    }
    else {
        throw new Error('Failed to parse fixed-length string');
    }
}
export function makeRegExpClass(regex, valueParser) {
    return class RegExpClass {
        constructor(length, value) {
            this.length = length;
            this.value = value;
            objectReferences.push(this);
        }
        static build(input) {
            const matches = input.match(regex);
            if (matches !== null) {
                const value = valueParser(matches[1]);
                return new this(matches[0].length, value);
            }
            else {
                throw new Error('Failed to parse ' + this.name);
            }
        }
        toJs() {
            return RegExpClass.toJs(this);
        }
        static toJs(instance) {
            return instance.value;
        }
    };
}
export var PHPTypes;
(function (PHPTypes) {
    class PHPReference {
        constructor(length, value) {
            this.length = length;
            this.value = value;
        }
        static build(input) {
            const matches = input.match(this.regex);
            if (matches !== null) {
                const value = parseInt(matches[1]);
                if (!(value in objectReferences)) {
                    throw new Error('Invalid Reference');
                }
                const object = objectReferences[value];
                if (object instanceof PHPReference) {
                    throw new Error('Invalid Reference');
                }
                return new this(matches[0].length, object);
            }
            else {
                throw new Error('Failed to parse PHPReference');
            }
        }
        toJs(options = {}) {
            return PHPReference.toJs(this, options);
        }
        static toJs(instance, options = {}) {
            return toJs(instance.value, options);
        }
    }
    PHPReference.regex = /^[Rr]:([^;]+);/;
    PHPTypes.PHPReference = PHPReference;
    class PHPBoolean extends makeRegExpClass(/^b:([01]);/, input => Boolean(parseInt(input))) {
    }
    PHPTypes.PHPBoolean = PHPBoolean;
    class PHPFloat extends makeRegExpClass(/^d:([^;]+);/, input => parseFloat(input.replace('INF', 'Infinity'))) {
    }
    PHPTypes.PHPFloat = PHPFloat;
    class PHPInteger extends makeRegExpClass(/^i:([^;]+);/, input => parseInt(input)) {
    }
    PHPTypes.PHPInteger = PHPInteger;
    class PHPNull extends makeRegExpClass(/^N;/, input => null) {
        constructor() {
            super(2, null);
        }
    }
    PHPTypes.PHPNull = PHPNull;
    class PHPCustomObject {
        constructor(length, value, className) {
            this.length = length;
            this.value = value;
            this.className = className;
            objectReferences.push(this);
        }
        static build(input) {
            const matches = input.match(this.regex);
            if (matches !== null) {
                let offset = matches[0].length;
                const [className, classNameLength] = parseFixedLengthString(input.substr(offset));
                offset += classNameLength;
                if (input.substr(offset, 1) === ':') {
                    offset += 1;
                }
                else {
                    throw new Error('Failed to parse ' + this.name);
                }
                let [value, valueLength] = parseFixedLengthString(input.substr(offset), '{', '}');
                offset += valueLength;
                return new this(offset, value, className);
            }
            else {
                throw new Error('Failed to parse ' + this.name);
            }
        }
        toJs() {
            return toJs(this);
        }
        static toJs(instance) {
            return instance.value;
        }
    }
    PHPCustomObject.regex = /^C:/;
    PHPTypes.PHPCustomObject = PHPCustomObject;
    class MappedData {
        static parseMap(input, openingDelimiter = '{', closingDelimiter = '}') {
            const countMatches = input.match(this.mapRegex);
            if (countMatches !== null) {
                const count = parseInt(countMatches[1]);
                let offset = countMatches[0].length;
                if (input.substr(offset, openingDelimiter.length) === openingDelimiter) {
                    offset += openingDelimiter.length;
                }
                else {
                    throw new Error('Failed to parse ' + this.name);
                }
                const map = new Map();
                for (let i = 0; i < count; i++) {
                    const key = _parse(input.substr(offset));
                    offset += key.length;
                    // Keys cannot be referenced
                    objectReferences.pop();
                    const value = _parse(input.substr(offset));
                    offset += value.length;
                    map.set(key, value);
                }
                if (input.substr(offset, closingDelimiter.length) === closingDelimiter) {
                    offset += closingDelimiter.length;
                }
                else {
                    throw new Error('Failed to parse ' + this.name);
                }
                return [map, offset];
            }
            else {
                throw new Error('Failed to parse ' + this.name);
            }
        }
    }
    MappedData.mapRegex = /(\d+):/;
    PHPTypes.MappedData = MappedData;
    class PHPObject extends MappedData {
        constructor(length, value, className) {
            super();
            this.length = length;
            this.value = value;
            this.className = className;
            this.jsValue = {};
            objectReferences.push(this);
        }
        static build(input) {
            const matches = input.match(this.regex);
            if (matches !== null) {
                let offset = matches[0].length;
                const [className, classNameLength] = parseFixedLengthString(input.substr(offset));
                offset += classNameLength;
                if (input.substr(offset, 1) === ':') {
                    offset += 1;
                }
                else {
                    throw new Error('Failed to parse ' + this.name);
                }
                const instance = new this(offset, new Map(), className);
                const [map, valueLength] = this.parseMap(input.substr(offset));
                offset += valueLength;
                instance.length = offset;
                instance.value = map;
                return instance;
            }
            else {
                throw new Error('Failed to parse ' + this.name);
            }
        }
        toJs(options = {}) {
            return toJs(this, options);
        }
        static propertyInfo(propertyName, className) {
            let accessModifier = 'public';
            const protectedRegExp = /^\u0000\*\u0000/;
            // Also handle double nulls caused by fixing missing nulls
            const privateRegExp = new RegExp(`^\u0000(\u0000${className}|${className}\u0000)`);
            if (propertyName.charCodeAt(0) === 0) {
                if (protectedRegExp.test(propertyName)) {
                    propertyName = propertyName.replace(protectedRegExp, '');
                    accessModifier = 'protected';
                }
                else if (privateRegExp.test(propertyName)) {
                    propertyName = propertyName.replace(privateRegExp, '');
                    accessModifier = 'private';
                }
            }
            return { accessModifier, propertyName };
        }
        static toJs(instance, options = {}) {
            const optionsHash = JSON.stringify(options);
            const cached = instance.jsValue[optionsHash];
            if (cached) {
                return cached;
            }
            const output = {};
            for (const [PHPKey, PHPValue] of instance.value.entries()) {
                let key = PHPKey.toJs();
                if (typeof key === 'string') {
                    let { accessModifier, propertyName } = this.propertyInfo(key, instance.className);
                    key = propertyName;
                    if (accessModifier !== 'public' && !options.private) {
                        continue;
                    }
                }
                output[key] = PHPValue;
            }
            instance.jsValue[optionsHash] = output;
            return output;
        }
    }
    PHPObject.regex = /^O:/;
    PHPTypes.PHPObject = PHPObject;
    class PHPArray extends MappedData {
        constructor(length, value) {
            super();
            this.length = length;
            this.value = value;
            this.jsValue = {};
            objectReferences.push(this);
        }
        static build(input) {
            const matches = input.match(this.regex);
            if (matches !== null) {
                let offset = matches[0].length;
                const instance = new this(offset, new Map());
                const [map, mapLength] = this.parseMap(input.substr(offset));
                offset += mapLength;
                instance.length = offset;
                instance.value = map;
                return instance;
            }
            else {
                throw new Error('Failed to parse ' + this.name);
            }
        }
        toJs(options = {}) {
            return toJs(this, options);
        }
        static toJs(instance, options = {}) {
            const optionsHash = JSON.stringify(options);
            const cached = instance.jsValue[optionsHash];
            if (cached) {
                return cached;
            }
            // Borrow the toJs method from PHPObject, then attempt to convert the result to an array.
            const outputObject = PHPObject.toJs(instance, options);
            if (options.detectArrays) {
                const outputArray = [];
                const stringKeys = Object.keys(outputObject);
                const numberKeys = [];
                if (stringKeys.length === 0)
                    return [];
                const allKeysAreNumbers = stringKeys.every(stringKey => {
                    const numberKey = parseInt(stringKey);
                    numberKeys.push(numberKey);
                    return numberKey.toString() === stringKey;
                });
                if (allKeysAreNumbers) {
                    for (const numberKey of numberKeys) {
                        outputArray[numberKey] = outputObject[numberKey];
                    }
                    instance.jsValue[optionsHash] = outputArray;
                    return outputArray;
                }
            }
            instance.jsValue[optionsHash] = outputObject;
            return outputObject;
        }
    }
    PHPArray.regex = /^a:/;
    PHPTypes.PHPArray = PHPArray;
    class PHPString {
        constructor(length, value) {
            this.length = length;
            this.value = value;
            objectReferences.push(this);
        }
        static build(input) {
            const matches = input.match(this.regex);
            if (matches !== null) {
                let offset = matches[0].length;
                let [value, valueLength] = parseFixedLengthString(input.substr(offset));
                offset += valueLength;
                if (input.substr(offset, 1) === ';') {
                    offset += 1;
                }
                else {
                    throw new Error('Failed to parse ' + this.name);
                }
                return new this(offset, value);
            }
            else {
                throw new Error('Failed to parse ' + this.name);
            }
        }
        toJs() {
            return PHPString.toJs(this);
        }
        static toJs(instance) {
            // Remove nulls from lambdas
            if (/^\u0000lambda_\d+$/.test(instance.value)) {
                return instance.value.replace(/\u0000/g, '');
            }
            return instance.value;
        }
    }
    PHPString.regex = /^s:/;
    PHPTypes.PHPString = PHPString;
    function createIdentifierMap(map) {
        return map;
    }
    PHPTypes.identifierMap = createIdentifierMap({
        C: PHPCustomObject,
        N: PHPNull,
        O: PHPObject,
        R: PHPReference,
        S: PHPString,
        a: PHPArray,
        b: PHPBoolean,
        d: PHPFloat,
        i: PHPInteger,
        r: PHPReference,
        s: PHPString,
    });
})(PHPTypes || (PHPTypes = {}));
